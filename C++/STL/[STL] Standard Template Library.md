# 설명
**S**tandard **T**emplate **L**ibrary란 C++에서 제공하는 표준 템플릿 라이브러리로 C++ template을 이용해 Generic(일반화: 타입에 무관한)한 프로그래밍이 가능합니다.

## STL 구성요소
STL은 Container(컨테이너, 자료구조) Class, Iterator(반복자), Algorithm(알고리즘) 그리고 Function Object(함수자)라고 불리는 네 가지의 구성요소로 구성되어 있습니다.

### 컨테이너
**컨테이너**는 객체 또는 데이터를 담는 컬렉션 또는 자료구조로 크게 순차 컨테이너, 연관 컨테이너, 비정렬 연관 컨테이너, 컨테이너 어댑터로 나눠집니다.

* 순차(시퀀스) 컨테이너
    → 특별한 규칙이 없는 컨테이너, 순서가 있는 선형구조
    * array                     : 배열
    * vector                    : 동적 배열
    * deque                     : 양방향 큐
    * list                      : 양방향 리스트
    * forward_list(C++11)       : 단방향 리스트

* 연관 컨테이너
    → 특정 규칙에 의해 정렬되는 컨테이너, 순서가 없는 비선형 구조
    * set                       : 정렬된 유일 Key 집합
    * map                       : 정렬된 유일 Key와 Value 집합
    * multiset                  : 정렬된 중복허용 Key 집합
    * multimap                  : 정렬된 중복허용 Key와 Value의 집합

* 비정렬 연관 컨테이너
    * unorder_set(C++11)        : 유일 Key 해시
    * unorder_map(C++11)        : 유일 Key와 Value의 해시
    * unorder_multiset(C++11)   : 중복허용 Key 해시
    * unorder_multimap(C++11)   : 중복허용 Key와 Value의 해시

* 컨테이너 어댑터
    → 간결함과 명료성을 위해 인터페이스를 제한한 컨테이너, 반복자를 지원하지 않아 STL 알고리즘을 사용할 수 없다.
    * stack                     : 스택
    * queue                     : 큐
    * priority_queue            : 우선순위큐

**순차 컨테이너**의 경우 요소가 언제 삽입되는지에 따라 배열안에서 요소의 순서가 결정된다. 즉, 연속되게 저장되는 배열과 같은 구조입니다. 하지만 특이하게 `list`는 다음 요소의 주소를 가리키는 노드구조를 가지고 있습니다.

**연관 컨테이너**는 어느 기준에 따라 자동으로 정렬하는 컨테이너 입니다. 따라서 순서가 없고 기준에 따라 다음 요소의 메모리 주소를 가리키는 노드구조입니다.

### 반복자
**반복자**는 포인터의 개념을 품은(또는 비슷한) 객체로 컨테이너에 저장된 요소를 반복적으로 순회하여 요소를 가리키고, 그 요소에 접근해 다음 요소를 가리키게합니다. 즉, 요소의 타입에 상관없이 독립적으로 요소를 순회하는 과정을 수행할 수 있습니다.

반복자는 다음과 같은 특징을 가집니다.
* 컨테이너 내부의 객체에 접근할 수 있어야 한다.
    → 참조 연산자(`*`)가 정의되어 포인터처럼 객체에 접근한다.
* 반복자는 다음 객체로 이동하고 컨테이너의모든 객체를 순회할 수 있어야 한다.
    → 증가 연산자(`++`)가 정의되어 포인터 변수처럼 증감 연산자로 다음 요소로 순회한다.
* 반복자의 위치를 판단할 수 있어야 한다.
    → `=`, `==`, `!=`와 같은 반복자간의 대입, 비교 연산자가 정의되어 있어 반복자의 위치를 파악할 수 있어야 한다.

반복자는 다음과 같은 5가지로 구성되어있습니다.
* 입력 반복자(input iterator)
    → 현재 위치의 객체의 값을 읽어 오는 반복자로, 증가 연산자를 사용하여 순방향으로만 이동할 수 있다.
* 출력 반복자(output iterator)
    → 현재 위치의 객체의 값을 변경할 수 있는 반복자로, 증가 연산자를 사용하여 순방향으로만 이동할 수 있다.
* 순방향 반복자(forward iterator)
    → 입력, 출력 반복자의 기능을 모두 가진 반복자로, 순방향으로 이동이 가능하며 재할당이 가능하다.
* 양방향 반복자(bidirectional iterator)
    → 순방향 반복자 기능에 역방향으로 이동(`--`)이 가능한 반복자이다.
* 임의 접근 반복자(random access iterator)
    → 양방향 반복자 기능과 `[]`를 사용해 임의의 요소에 접근이 가능한 반복자로 모든 컨테이너는 양방향 반복자와 임의 접근 반복자를 지원한다.

### 알고리즘
STL에서 제공하는 알고리즘은 검색이나 정렬같은 활동을 수행하는 것으로 대부분은 반복자의 특정한 수준을 요구합니다. 알고리즘은 다음과 같은 4가지로 구성되어 있습니다.

* 읽기 알고리즘
    → 컨테이너를 변경하지 않으며, 컨테이너의 지정된 범위에서 특정 데이터를 읽기만 하는 알고리즘, `algorithm` 헤더에 정의되어 있다.
* 변경 알고리즘
    → 컨테이너를 변경하지 않으며, 컨테이너의 지정된 범위에서 요소의 값만을 변경할 수 있는 알고리즘, `algorithm` 헤더에 정의되어 있다.
* 정렬 알고리즘
    → 컨테이너의 지정된 범위의 요소들을 정렬되도록 컨테이너를 변경하는 알고리즘, `algorithm` 헤더에 정의되어 있다.
* 수치 알고리즘
    → STL에 직접 속하지 않고 C++라이브러리로 분류되는 알고리즘으로 수치적 해석을 위해 사용, `numeric` 헤더에 정의되어 있다.

### 함수자
STL은 함수 호출 연산자(`operator()`)를 오버로드하는 클래스들을 포함합니다. 이러한 클래스들의 인스턴스들은 함수자 또는 함수 객체라고 불립니다. 함수자들은 연관된 함수가 파라미터화되는 행동을 허용하고 (예를 들어 함수자의 생성자로 넘겨지는 인자를 통해서) 연관된 per-functor 상태를 함수와 함께  사용될 수 있게 유지합니다. 함수자와 함수 포인터 모두 함수 호출의 문법을 사용해서 유발될 수 있기 때문에, 이것들은 상응하는 파라미터가 오직 함수 호출 문맥에서만 보일 때 인자로서 교체될 수 있습니다.

# 참고 자료
[cppreference](https://ko.cppreference.com/w/cpp/container)
[VisualC++ Docs](https://learn.microsoft.com/ko-kr/cpp/standard-library/cpp-standard-library-overview?view=msvc-170)
[cpluscplus - stl](https://cplusplus.com/reference/stl/?kw=stl)
[cpluscplus - iterator](https://cplusplus.com/reference/iterator/)
[위키백과](https://ko.wikipedia.org/wiki/%ED%91%9C%EC%A4%80_%ED%85%9C%ED%94%8C%EB%A6%BF_%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC)
[나무위키](https://namu.wiki/w/%ED%91%9C%EC%A4%80%20%ED%85%9C%ED%94%8C%EB%A6%BF%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC)
[BlockDMask](https://blockdmask.tistory.com/67)
[소년코딩](https://boycoding.tistory.com/124)
